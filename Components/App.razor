<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <base href="/" />
    <ResourcePreloader />
    <link rel="stylesheet" href="@Assets["lib/bootstrap/dist/css/bootstrap.min.css"]" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css" />
    <link rel="stylesheet" href="@Assets["app.css"]" />
    <link rel="stylesheet" href="@Assets["ClaimsPortal.styles.css"]" />
    <ImportMap />
    <link rel="icon" type="image/png" href="favicon.png" />
    <HeadOutlet />
</head>

<body>
    <Routes />
    <ReconnectModal />
    @using ClaimsPortal.Components.Modals
    @inject ClaimsPortal.Services.HospitalSearchCoordinator HospitalSearchCoordinator

    <!-- Shared Hospital Search Modal used by multiple components to keep behavior consistent -->
    <HospitalSearchModal ModalId="hospitalSearchModal_shared"
                         OnHospitalSelected="@(async (ClaimsPortal.Models.HospitalInfo h) => await HospitalSearchCoordinator.NotifySelection(h))"
                         OnManualEntry="@(() => { HospitalSearchCoordinator.UnregisterCallback(); })"
                         OnCancelled="@(() => { HospitalSearchCoordinator.UnregisterCallback(); })" />
    <script src="@Assets["_framework/blazor.web.js"]"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/js/letterEditor.js"></script>
    <script>
        window.ShowModal = async function (modalId) {
            try {
                const findModal = (id) => document.getElementById(id);

                const waitForModal = (id, timeoutMs = 2000) => new Promise((resolve) => {
                    const start = Date.now();
                    const tick = () => {
                        const m = findModal(id);
                        if (m) return resolve(m);
                        if (Date.now() - start > timeoutMs) return resolve(null);
                        setTimeout(tick, 50);
                    };
                    tick();
                });

                const modal = findModal(modalId) || await waitForModal(modalId, 2000);
                if (!modal) {
                    console.warn('ShowModal: element not found by id', modalId);
                    return;
                }

                // Do not reparent modals into document.body — moving DOM nodes managed by
                // Blazor breaks the renderer (it may later try to remove/update nodes that
                // no longer have the expected parent). Keep modals in-place and rely on
                // Bootstrap's default behavior.

                const options = { backdrop: true, keyboard: true };
                const instance = bootstrap.Modal.getOrCreateInstance(modal, options);
                instance.show();
            } catch (e) {
                console.warn('ShowModal error', e);
            }
        };

        window.HideModal = function (modalId) {
            try {
                const modal = document.getElementById(modalId);
                if (!modal) return;
                const instance = bootstrap.Modal.getInstance(modal) || bootstrap.Modal.getOrCreateInstance(modal);
                instance.hide();

                // No reparenting to perform — keeping modal markup in-place prevents
                // Blazor DOM reconciliation errors.
            } catch (e) {
                console.warn('HideModal error', e);
            }
        };
        // Client-side console logger: posts errors/warns to server for debugging
        (function () {
            const sendLog = (level, message, extra) => {
                try {
                    fetch('/api/clientlogs', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ level: level, message: message, extra: extra, url: location.href, ua: navigator.userAgent })
                    });
                } catch (e) { }
            };

            const origError = console.error.bind(console);
            console.error = function (...args) {
                try { sendLog('error', args.map(a => (typeof a === 'string' ? a : JSON.stringify(a))).join(' ')); } catch (e) { }
                origError(...args);
            };

            const origWarn = console.warn.bind(console);
            console.warn = function (...args) {
                try { sendLog('warn', args.map(a => (typeof a === 'string' ? a : JSON.stringify(a))).join(' ')); } catch (e) { }
                origWarn(...args);
            };

            const origLog = console.log.bind(console);
            console.log = function (...args) {
                try { sendLog('info', args.map(a => (typeof a === 'string' ? a : JSON.stringify(a))).join(' ')); } catch (e) { }
                origLog(...args);
            };

            window.addEventListener('error', function (ev) {
                try {
                    sendLog('error', ev.message + ' @@' + ev.filename + ':' + ev.lineno + ':' + ev.colno, { stack: ev.error && ev.error.stack });
                    // If this is the known bootstrap DOM timing error that reads 'removeChild' on null,
                    // prevent it from becoming an unhandled exception that terminates the Blazor circuit.
                    if (ev && ev.message && ev.message.indexOf('removeChild') !== -1) {
                        try { ev.preventDefault(); } catch { }
                    }
                } catch (e) { }
            });

            window.addEventListener('unhandledrejection', function (ev) {
                try {
                    sendLog('error', 'UnhandledRejection', { reason: ev.reason && (ev.reason.message || JSON.stringify(ev.reason)) });
                    if (ev && ev.reason && typeof ev.reason === 'string' && ev.reason.indexOf('removeChild') !== -1) {
                        try { ev.preventDefault(); } catch { }
                    }
                    if (ev && ev.reason && ev.reason.message && ev.reason.message.indexOf && ev.reason.message.indexOf('removeChild') !== -1) {
                        try { ev.preventDefault(); } catch { }
                    }
                } catch (e) { }
            });
        })();
    </script>
</body>

</html>
