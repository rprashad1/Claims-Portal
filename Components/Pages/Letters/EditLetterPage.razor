@page "/letters/edit/{ClaimNumber}/{DocumentNumber}/{TemplateName}"
@using System.Net.Http.Json
@inject IHttpClientFactory HttpClientFactory
@inject IJSRuntime JS
@inject NavigationManager NavigationManager

<h3>Load Template</h3>
<p class="text-muted">Claim: @ClaimNumber • Document: @DocumentNumber • Template: @TemplateName</p>

@if (IsLoading)
{
    <div>Loading template...</div>
}
else
{
    <div>
        <div id="editContent" contenteditable="true" style="min-height:60vh;border:1px solid #ddd;padding:12px;background:#fff;overflow:auto">@((MarkupString)editedHtml)</div>

        <div class="mt-3">
            <button class="btn btn-secondary me-2" onclick="letterEditor.cancel('@ClaimNumber')">Cancel</button>
            <button class="btn btn-primary" onclick="letterEditor.saveAndGenerate('@ClaimNumber','@DocumentNumber','@TemplateName','@(RuleId ?? string.Empty)')">Save / Generate PDF</button>
        </div>
        @if (!string.IsNullOrEmpty(Status))
        {
            <div class="mt-2 text-muted">@Status</div>
        }
    </div>
}

@code {
    [Parameter] public string ClaimNumber { get; set; } = string.Empty;
    [Parameter] public string DocumentNumber { get; set; } = string.Empty;
    [Parameter] public string TemplateName { get; set; } = string.Empty;

    private ElementReference editDiv;
    private string editedHtml = string.Empty;
    private bool IsLoading = true;
    private string? Status;
    private string? RuleId;

    protected override async Task OnInitializedAsync()
    {
        // read optional ruleId from query string
        var uri = new Uri(NavigationManager.Uri);
        var qs = Microsoft.AspNetCore.WebUtilities.QueryHelpers.ParseQuery(uri.Query);
        if (qs.TryGetValue("ruleId", out var v)) RuleId = v.ToString();
        await LoadRenderedHtmlAsync();
    }

    private async Task LoadRenderedHtmlAsync()
    {
        IsLoading = true;
        try
        {
            var client = HttpClientFactory.CreateClient();
            client.BaseAddress = new Uri(NavigationManager.BaseUri);
            var payload = new Dictionary<string, object>
            {
                ["templateName"] = TemplateName,
                ["claimNumber"] = ClaimNumber,
                ["documentNumber"] = DocumentNumber
            };
            if (!string.IsNullOrEmpty(RuleId)) payload["ruleId"] = RuleId;

            var resp = await client.PostAsJsonAsync("/api/letters/form/render", payload);
            if (resp.IsSuccessStatusCode)
            {
                editedHtml = await resp.Content.ReadAsStringAsync();
            }
            else
            {
                editedHtml = "<div class=\"text-danger\">Failed to load template for edit.</div>";
            }
        }
        catch (Exception ex)
        {
            editedHtml = $"<div class=\"text-danger\">Error: {ex.Message}</div>";
        }
        finally
        {
            IsLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void Cancel()
    {
        // close window/tab if opened separately, otherwise navigate back
        JS.InvokeVoidAsync("close");
        NavigationManager.NavigateTo($"/claim/{ClaimNumber}");
    }

    private async Task SaveAndGenerate()
    {
        Status = "Generating PDF...";
        StateHasChanged();
        try
        {
            var client = HttpClientFactory.CreateClient();
            client.BaseAddress = new Uri(NavigationManager.BaseUri);
            var currentHtml = await JS.InvokeAsync<string>("letterEditor.getHtml", editDiv);
            // send a small client-side log so we have a record the user clicked Save
            try
            {
                var clientLog = new Dictionary<string, object>
                {
                    ["message"] = "SaveAndGenerate clicked",
                    ["claimNumber"] = ClaimNumber,
                    ["documentNumber"] = DocumentNumber,
                    ["templateName"] = TemplateName,
                    ["htmlLength"] = currentHtml?.Length ?? 0
                };
                // fire-and-forget the client log (server will append to logs/clientlogs.txt)
                _ = client.PostAsJsonAsync("/api/clientlogs", clientLog);
            }
            catch { }

            var payload = new Dictionary<string, object>
            {
                ["claimNumber"] = ClaimNumber,
                ["documentNumber"] = DocumentNumber,
                ["templateName"] = TemplateName,
                ["html"] = currentHtml
            };
            if (!string.IsNullOrEmpty(RuleId)) payload["ruleId"] = RuleId;

            var resp = await client.PostAsJsonAsync("/api/letters/form/saveHtml", payload);
            if (resp.IsSuccessStatusCode)
            {
                var obj = await resp.Content.ReadFromJsonAsync<Dictionary<string, string>>();
                if (obj != null && obj.TryGetValue("url", out var url))
                {
                    Status = "Letter saved please close";
                    await JS.InvokeVoidAsync("open", url, "_blank");
                    // refresh claim page so grid shows new record
                    NavigationManager.NavigateTo($"/claim/{ClaimNumber}", forceLoad: true);
                    return;
                }
                Status = "Letter saved please close";
            }
            else
            {
                var txt = await resp.Content.ReadAsStringAsync();
                Status = "Generation failed: " + txt;
            }
        }
        catch (Exception ex)
        {
            Status = "Error: " + ex.Message;
        }
        StateHasChanged();
    }
}
